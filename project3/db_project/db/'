#include "buffer.h"

LRU_Buffer Buffer;

buf_block_t* alloc_buf_block_t(bool create_frame, int64_t tid, pagenum_t pn){
    buf_block_t* ctrl_block = (buf_block_t*)malloc(sizeof(buf_block_t));
    if(create_frame){
        ctrl_block->frame = (frame_t*)malloc(sizeof(frame_t)); 
        ctrl_block->is_dirty = 0;
        ctrl_block->is_pinned = 0;
    } 
    else {
        ctrl_block->frame = nullptr;
        //-1 means not using this value
        ctrl_block->is_dirty = -1;
        ctrl_block->is_pinned = -1;
    }
    ctrl_block->table_id = tid;
    ctrl_block->pagenum = pn;
    return ctrl_block;
}

LRU_Buffer::LRU_Buffer(){
    frame_in_use = 0;
    //buf_block of tid -2 is head and tail.
    head = alloc_buf_block_t(false, -2, 0);
    tail = alloc_buf_block_t(false, -2, 0);
    head->next = tail;
    tail->prev = head;
}

void LRU_Buffer::add_frame_front(buf_block_t* target){
    buf_block_t* temp = head->next;
    target->next = head->next;
    head->next = target;
    target->prev = temp->prev;
    temp->prev = target;
}

int init_buffer(int num_buf){
    Buffer = LRU_Buffer();
    Buffer.frame_total = num_buf;
    Buffer.print_buf_block();
    return 0;
}

int buf_read_page(int64_t table_id, pagenum_t pagenum, struct page_t* dest){
    //cache hit!
    if(Buffer.page_buf_block_map.find({table_id, pagenum})!=Buffer.page_buf_block_map.end()){
        printf("Cache hit\n");
        memcpy(dest, Buffer.page_buf_block_map[{table_id,pagenum}]->frame, PAGE_SIZE);
        Buffer.page_buf_block_map[{table_id, pagenum}]->is_pinned += 1;
        return 0;      
    }
    
    //Buffer is not full 
    if(Buffer.frame_total > Buffer.frame_in_use){
        printf("Buf control block not full, so insert\n");

        // new buf_block initialize
        buf_block_t* new_buf_block = alloc_buf_block_t(true, table_id, pagenum); 
        new_buf_block->is_pinned += 1;
        file_read_page(table_id, pagenum, (page_t*)new_buf_block->frame);

        // return cached page
        memcpy(dest, new_buf_block->frame, PAGE_SIZE);

        // update Buffer 
        Buffer.add_frame_front(new_buf_block); 
        Buffer.frame_in_use++;
        Buffer.page_buf_block_map.insert({{table_id, pagenum},new_buf_block});

        return 0;
    } 
    else if(Buffer.frame_total < Buffer.frame_in_use){
        printf("Must not be occured case occured!\n");
        return -1;
    } 
    // Buffer is full, evict the victim page, traversing from tail.
    else {
        buf_block_t* cur = Buffer.tail->prev; 
        bool exit_flag = false;
        // header frame has table id of -2
        while(cur->table_id!=-2){
            if(cur->is_pinned == 0){
                break; 
            }
            cur = cur->prev;
        }
        if(cur->table_id==-2){
            printf("ERROR: BUFFER is full and all frames are in use");
            return -1;
        }
        
    }

}
